#pragma once#include <objective-functions/element.h>/**	This class implements the interface for an elementary energy unit. As a function of deformed, undeformed,	and other parameters, such as boundary conditions, each class that extends this one will define a potential energy.	The deformed energy depends on a number of nodes.*/class TriangleAreaPreserving : public Element {public:	TriangleAreaPreserving(const VectorXi &F, const VectorXd &V, const int faceIndex){		this->faceIndex = faceIndex;		Vector3i VertexIndexes = F.row(faceIndex);		for (int i = 0; i < getNumNodes(); i++) {			this->vertexIndexes[i] = VertexIndexes(i);			this->vertexPos[i] = V.row(VertexIndexes(i));		}	}	virtual ~TriangleAreaPreserving() {}	// Returns the number of nodes this unit depends on	virtual int getNumNodes() const {		return 3;	}	// Returns the global index of node `i`	virtual int getNodeIndex(int i) const {		return vertexIndexes[i];	}	virtual Vector3d getNodePos(int i) const {		return vertexPos[i];	}	// Returns the global index of the face	int getFaceIndex() const {		return faceIndex;	}	double ComputeArea(const Vector2d p0, const Vector2d p1, const Vector2d p2) const {	}	Vector2d getBp(const int index) const {		double A = ComputeArea(v1, v2, v3);		Vector2d E;		if (index == 0) {			//TODO: compute E		}		else if (index == 1) {			//TODO: compute E		}		else {			//TODO: compute E		}		E.normalize();		return E / (2 * A);	}	Vector3d getDxDy(Vector3d& Dx, Vector3d& Dy) const {		Vector2d B0 = getBp(0);		Vector2d B1 = getBp(1);		Vector2d B2 = getBp(2);			Dx << B0.x, B1.x, B2.x;		Dy << B0.y, B1.y, B2.y;	}		Vector3d getX() const {	}	Vector3d getY() const {	}		// Returns the energy value given deformed `x` and undeformed `X` state	virtual double getEnergy(const VectorXd& x123, const VectorXd& X123) {		//	E = (det(J) - 1)^2		//		//	J = (a b) = (DxX DxY)		//		(c d)   (DyX DyY)		//		//	det(J) = ad - bc		//		//	E = (ad-bc-1)^2		Vector3d Dx, Dy;		getDxDy(Dx, Dy);		Vector3d X = getX();		Vector3d Y = getY();		double a = Dx.transpose() * X;		double b = Dx.transpose() * Y;		double c = Dy.transpose() * X;		double d = Dy.transpose() * Y;		return pow(((a*d) - (b*c) - 1), 2);	}	// Adds the gradient to `grad` given deformed `x` and undeformed `X` state	virtual void addEnergyGradientTo(const VectorXd& x, const VectorXd& X, VectorXd& grad) {	}	// Adds the hessian entries to `hesEntries` given deformed `x` and undeformed `X` state	virtual void addEnergyHessianTo(const VectorXd& x, const VectorXd& X, std::vector<Tripletd>& hesEntries) {	}protected:	// the collection of nodes that define the triangle element	int faceIndex;	int vertexIndexes[3];	Vector3d vertexPos[3];};