#pragma once#include <objective-functions/element.h>/**	This class implements the interface for an elementary energy unit. As a function of deformed, undeformed,	and other parameters, such as boundary conditions, each class that extends this one will define a potential energy.	The deformed energy depends on a number of nodes.*/class Spring : public Element {public:	Spring(const std::array<int, 2> &nodeIndices, const VectorXd &X)		: nodeIndices(nodeIndices) {	}	virtual ~Spring() {}	// Returns the number of nodes this unit depends on	virtual int getNumNodes() const {		return 2;	}	// Returns the global index of node `i`	virtual int getNodeIndex(int i) const {		return nodeIndices[i];	}	// Returns the element's mass	virtual double getMass() const {		return 0;	}	// Returns the energy value given deformed `x` and undeformed `X` state	virtual double getEnergy(const VectorXd& x, const VectorXd& X) {		Vector2d x0 = getNodePos(0, x);		Vector2d x1 = getNodePos(1, x);		Vector2d X0 = getNodePos(0, X);		Vector2d X1 = getNodePos(1, X);		double l = (x0 - x1).norm();		double L = (X0 - X1).norm();		double Ek = 0.5 * k * pow(l / L - 1, 2) * L; 		return Ek;	}	// Adds the gradient to `grad` given deformed `x` and undeformed `X` state	virtual void addEnergyGradientTo(const VectorXd& x, const VectorXd& X, VectorXd& grad) {		double dx0, dy0, dx1, dy1;		Vector2d x0 = getNodePos(0, x);		Vector2d x1 = getNodePos(1, x);		double l = (x0 - x1).norm();		double L = (getNodePos(0, X) - getNodePos(1, X)).norm();		int globalIndex0 = getNodeIndex(0);		int globalIndex1 = getNodeIndex(1);				dx0 = (k * (l - L) * (x0[0] - x1[0])) / (l*L);		dy0 = (k * (l - L) * (x0[1] - x1[1])) / (l*L);		dx1 = -dx0;		dy1 = -dy0;		grad[(globalIndex0 * 2) + 0] += dx0;		grad[(globalIndex0 * 2) + 1] += dy0;		grad[(globalIndex1 * 2) + 0] += dx1;		grad[(globalIndex1 * 2) + 1] += dy1;	}	// Adds the hessian entries to `hesEntries` given deformed `x` and undeformed `X` state	virtual void addEnergyHessianTo(const VectorXd& x, const VectorXd& X, std::vector<Tripletd>& hesEntries) {		Vector2d x0 = getNodePos(0, x);		Vector2d x1 = getNodePos(1, x);		double l = (x0 - x1).norm();		double L = (getNodePos(0, X) - getNodePos(1, X)).norm();		int globalIndex0 = getNodeIndex(0);		int globalIndex1 = getNodeIndex(1);		double Dx0x0 = (k / L) - (k / l) + ((pow(x0[0] - x1[0], 2) * k) / pow(l, 3)); //not sure		double Dx0x1 = -Dx0x0;		double Dx0y0 = (k*(x0[0] - x1[0])*(x0[1] - x1[1])) / pow(l, 3); //not sure		double Dx0y1 = -Dx0y0;		double Dx1x0 = -Dx0x0;		double Dx1x1 = -Dx0x1;		double Dx1y0 = -Dx0y0;		double Dx1y1 = -Dx0y1;		double Dy0x0 = Dx0y0; //not sure		double Dy0x1 = -Dy0x0;		double Dy0y0 = (k / L) - (k / l) + ((pow(x0[1] - x1[1], 2) * k) / pow(l, 3)); //not sure		double Dy0y1 = -Dy0y0;		double Dy1x0 = -Dy0x0;		double Dy1x1 = -Dy0x1;		double Dy1y0 = -Dy0y0;		double Dy1y1 = -Dy0y1;		hesEntries.push_back(Tripletd((globalIndex0 * 2) + 0, (globalIndex0 * 2) + 0, Dx0x0));		hesEntries.push_back(Tripletd((globalIndex0 * 2) + 0, (globalIndex0 * 2) + 1, Dx0y0));		hesEntries.push_back(Tripletd((globalIndex0 * 2) + 1, (globalIndex0 * 2) + 0, Dy0x0));		hesEntries.push_back(Tripletd((globalIndex0 * 2) + 1, (globalIndex0 * 2) + 1, Dy0y0));		hesEntries.push_back(Tripletd((globalIndex0 * 2) + 0, (globalIndex1 * 2) + 0, Dx0x1));		hesEntries.push_back(Tripletd((globalIndex0 * 2) + 0, (globalIndex1 * 2) + 1, Dx0y1));		hesEntries.push_back(Tripletd((globalIndex0 * 2) + 1, (globalIndex1 * 2) + 0, Dy0x1));		hesEntries.push_back(Tripletd((globalIndex0 * 2) + 1, (globalIndex1 * 2) + 1, Dy0y1));		hesEntries.push_back(Tripletd((globalIndex1 * 2) + 0, (globalIndex0 * 2) + 0, Dx1x0));		hesEntries.push_back(Tripletd((globalIndex1 * 2) + 0, (globalIndex0 * 2) + 1, Dx1y0));		hesEntries.push_back(Tripletd((globalIndex1 * 2) + 1, (globalIndex0 * 2) + 0, Dy1x0));		hesEntries.push_back(Tripletd((globalIndex1 * 2) + 1, (globalIndex0 * 2) + 1, Dy1y0));		hesEntries.push_back(Tripletd((globalIndex1 * 2) + 0, (globalIndex1 * 2) + 0, Dx1x1));		hesEntries.push_back(Tripletd((globalIndex1 * 2) + 0, (globalIndex1 * 2) + 1, Dx1y1));		hesEntries.push_back(Tripletd((globalIndex1 * 2) + 1, (globalIndex1 * 2) + 0, Dy1x1));		hesEntries.push_back(Tripletd((globalIndex1 * 2) + 1, (globalIndex1 * 2) + 1, Dy1y1));	}protected:	// the collection of nodes that define the triangle element	std::array<int, 2> nodeIndices;	// spring stiffness	double k = 20.0;};